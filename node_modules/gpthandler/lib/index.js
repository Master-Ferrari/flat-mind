"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.llmMethods = exports.Llm = exports.llmModelsEnum = void 0;
const types_1 = require("./types");
Object.defineProperty(exports, "llmModelsEnum", { enumerable: true, get: function () { return types_1.llmModelsEnum; } });
const g4f_1 = require("g4f");
const g4f = new g4f_1.G4F();
class OpenAiMethod {
    async requestChat(history) {
        return "not implemented";
    }
    async translate(text, from, to) {
        return "not implemented";
    }
}
class G4fMethod {
    async requestChat(history, model) {
        return await g4f.chatCompletion(history, { model: model });
    }
    async translate(text, from, to) {
        return (await g4f.translation({ source: from, target: to, text: text })).translation.result;
    }
}
class Llm {
    ShowError(error) {
        if (this.opt.errorHandlingMode == "as responce text") {
            return String(error);
        }
        else {
            throw error;
        }
    }
    constructor(options) {
        this.method = new G4fMethod();
        this.opt = {
            llmModel: types_1.llmModelsEnum.G4f.gpt4,
            retryCount: 3,
            errorHandlingMode: "as responce text"
        };
        this.setOptions(options);
    }
    setOptions(options) {
        this.opt = { ...this.opt, ...options };
        this.method = new Llm.methodClasses[this.opt.llmModel.method];
    }
    async retry(fn, ansChecker) {
        for (let i = 0; i < this.opt.retryCount; i++) {
            try {
                const ans = await fn();
                if (ansChecker(ans))
                    return ans;
            }
            catch (e) {
                console.error("(retry" + (i + 1) + "/" + this.opt.retryCount + ") Error : " + String(e));
                if (i >= this.opt.retryCount - 1) {
                    this.ShowError(e);
                }
            }
        }
    }
    async requestChat(history, ansChecker = () => true) {
        return this.retry(() => this.method.requestChat(history, this.opt.llmModel.model), ansChecker);
    }
    async translate(text, from, to) {
        if (!types_1.langCodes.find(x => x.id == from) || !types_1.langCodes.find(x => x.id == to))
            this.ShowError(new Error("Invalid language code"));
        return await this.method.translate(text, from, to);
    }
}
exports.Llm = Llm;
Llm.methodClasses = {
    "OpenAi": OpenAiMethod,
    "G4f": G4fMethod
};
exports.llmMethods = { OpenAi: new OpenAiMethod, G4f: new G4fMethod };
//# sourceMappingURL=index.js.map