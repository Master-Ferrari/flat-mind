import { ChatHistory, LlmOptions, Checker, LlmAns, llmModelsEnum, ModelData, LlmMethod, langCodes, TranslationResult } from "./types";
export { ChatHistory, LlmOptions, Checker, LlmAns, llmModelsEnum, ModelData };

import { G4F, chunkProcessor } from "g4f";
const g4f = new G4F();

class OpenAiMethod implements LlmMethod {
    async requestChat(history: ChatHistory): Promise<LlmAns> {
        return "not implemented";
    }

    async translate(text: string, from: string, to: string): Promise<string> {
        return "not implemented";
    }
}

class G4fMethod implements LlmMethod {
    async requestChat(history: ChatHistory, model: string): Promise<LlmAns> {
        return await g4f.chatCompletion(history as any, { model: model });
    }

    async translate(text: string, from: string, to: string): Promise<string> {
        return (await g4f.translation({ source: from, target: to, text: text }) as TranslationResult).translation.result;
    }

}

export class Llm {
    private static methodClasses: { [key: string]: new () => LlmMethod; } = {
        "OpenAi": OpenAiMethod,
        "G4f": G4fMethod
    };

    private method: LlmMethod = new G4fMethod();
    private opt: LlmOptions = {
        llmModel: llmModelsEnum.G4f.gpt4,
        retryCount: 3,
        errorHandlingMode: "as responce text"
    }

    private ShowError(error: any) {
        if (this.opt.errorHandlingMode == "as responce text") {
            return String(error);
        } else {
            throw error;
        }
    }

    constructor(options?: Partial<LlmOptions>) {
        this.setOptions(options);
    }

    setOptions(options?: Partial<LlmOptions>) {
        this.opt = { ...this.opt, ...options };
        this.method = new Llm.methodClasses[this.opt.llmModel.method];
    }

    private async retry(fn: () => Promise<any>, ansChecker: (arg: any) => boolean): Promise<any> {
        for (let i = 0; i < this.opt.retryCount; i++) {
            try {
                const ans = await fn();
                if (ansChecker(ans)) return ans;
            } catch (e) {
                console.error("(retry" + (i + 1) + "/" + this.opt.retryCount + ") Error : " + String(e))
                if (i >= this.opt.retryCount - 1) {
                    this.ShowError(e);
                }
            }
        }

    }

    async requestChat(history: ChatHistory, ansChecker: Checker = () => true): Promise<LlmAns> {
        return this.retry(() => this.method.requestChat(history, this.opt.llmModel.model), ansChecker);
    }

    async translate(text: string, from: string, to: string): Promise<LlmAns> {
        if (!langCodes.find(x => x.id == from) || !langCodes.find(x => x.id == to))
            this.ShowError(new Error("Invalid language code"));
        return await this.method.translate(text, from, to);
    }


}

export const llmMethods = { OpenAi: new OpenAiMethod, G4f: new G4fMethod };